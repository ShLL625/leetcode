import List, random

class ArrayString:
    # Merge Sorted Array
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        a, b, write_index = m-1, n-1, m + n - 1

        while b >= 0:
            if a >= 0 and nums1[a] > nums2[b]:
                nums1[write_index] = nums1[a]
                a -= 1
            else:
                nums1[write_index] = nums2[b]
                b -= 1
            write_index -= 1

    # Remove Element
    def removeElement(self, nums: List[int], val: int) -> int:
        while val in nums:
            nums.remove(val)
        return len(nums)
    
    # Remove Duplicates from Sorted Array
    def removeDuplicates(self, nums: List[int]) -> int:
        # Edge case: empty array
        if not nums:
            return 0

        # i tracks last unique element
        i = 0

        # j scans ahead to find new unique elements
        for j in range(1, len(nums)):
            if nums[j] != nums[i]:
                i += 1           # Move i to next position
                nums[i] = nums[j]  # Copy unique value to front
        # Return count of unique elements
        return i + 1
    
    # Remove Duplicates from Sorted Array II
    def removeDuplicatesII(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 3:
            return n
        
        i = 2
        for j in range(2, n):
            if nums[j] != nums[i - 2]:
                nums[i] = nums[j]
                i += 1        
        return i
    
    # Majority Element
    def majorityElement(self, nums: List[int]) -> int:
        sol = None
        cnt = 0
        for i in nums:
            if cnt == 0:
                sol = i
            cnt += (1 if i == sol else -1)
        return sol
    
    # Rotate Array
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n=len(nums)
        k=k%n
        nums[:]=nums[-k:]+nums[:-k]

    # Best Time to Buy and Sell Stock
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        maxProfit = 0
        minPurchase = prices[0]
        for price in prices:
            curProfit = price - minPurchase
            if curProfit > maxProfit:
                maxProfit = curProfit
            if price < minPurchase:
                minPurchase = price
        return maxProfit
    
    # Best Time to Buy and Sell Stock II
    def maxProfitII(self, prices: List[int]) -> int:
        lo, profit = prices[0], 0
        for price in prices[1:]:
            if price > lo:
                profit += (price - lo)
            lo = price
        return profit
    
    # Jump Game
    def canJump(self, nums: List[int]) -> bool:
        gas = 0
        for n in nums:
            if gas < 0:
                return False
            elif n > gas:
                gas = n
            gas -= 1           
        return True
    
    # Jump Game II
    def jumpII(self, nums: List[int]) -> int:
        # Initialize reach (maximum reachable index), count (number of jumps), and last (rightmost index reached)
        reach, count, last = 0, 0, 0
        
        # Loop through the array excluding the last element
        for i in range(len(nums)-1):    
            # Update reach to the maximum between reach and i + nums[i]
            reach = max(reach, i + nums[i])
        
            # If i has reached the last index that can be reached with the current number of jumps
            if i == last:
                # Update last to the new maximum reachable index
                last = reach
                # Increment the number of jumps made so far
                count += 1
        
        # Return the minimum number of jumps required
        return count
    
    # H-Index
    def hIndex(self, citations: List[int]) -> int:
        citations.sort(reverse=True)
        if len(citations)==1 and citations[0]>0:
            return 1
        if citations[-1]>=len(citations):
            return len(citations)
        for i in range(len(citations)):
            if citations[i]<i+1:
                return i
        return 0
    
    # Product of Array Except Self
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        prefix_product = 1
        postfix_product = 1
        result = [0]*n
        for i in range(n):
            result[i] = prefix_product
            prefix_product *= nums[i]
        for i in range(n-1,-1,-1):
            result[i] *= postfix_product
            postfix_product *= nums[i]
        return result
    
    # Gas Station
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost):
            return -1       
        curernt_gas = 0
        start = 0
        for i in range(len(gas)):
            curernt_gas += gas[i] - cost[i]
            if curernt_gas < 0:
                curernt_gas = 0
                start = i + 1
        return start
    
    # Candy
    def candy(self, ratings: List[int]) -> int:
        res = [1] * len(ratings)
        if len(res) == 1:
            return 1
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i-1]:
                res[i] = res[i-1] + 1
        for i in range(len(ratings) - 2, -1, -1):
            if ratings[i] > ratings[i+1]:
                if res[i] <= res[i+1]:
                    res[i] = res[i+1] + 1       
        return sum(res)
    
    # Trapping Rain Water
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        left, right = 0, len(height) - 1
        left_max, right_max = height[left], height[right]
        water_count = 0
        while left < right:
            if left_max <= right_max:
                left += 1
                left_max = max(left_max, height[left])
                water_count += max(0, left_max - height[left])
            else:
                right -= 1
                right_max = max(right_max, height[right])
                water_count += max(0, right_max - height[right])
        return water_count
    
    # Roman to Integer
    def romanToInt(self, s: str) -> int:
        roman={"I":1,"V":5,"X":10,"L":50,"C":100,"D":500,"M":1000}
        number=0
        for i in range(len(s)-1):
            if roman[s[i]] < roman[s[(i+1)]]:
                number-=roman[s[i]]
            else:
                number+=roman[s[i]]
        return number+roman[s[-1]]

# Insert Delete GetRandom O(1)    
class RandomizedSet:
    def __init__(self):
        self.dict = {}
        self.list = []

    def insert(self, val: int) -> bool:
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True

    def remove(self, val: int) -> bool:
        if val not in self.dict:
            return False
        # Move the last element to the place of the element to delete
        last_element = self.list[-1]
        idx_to_remove = self.dict[val]
        self.list[idx_to_remove] = last_element
        self.dict[last_element] = idx_to_remove
        # Remove the last element
        self.list.pop()
        del self.dict[val]
        return True

    def getRandom(self) -> int:
        return random.choice(self.list)
    
